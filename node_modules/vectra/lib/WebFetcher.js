"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebFetcher = void 0;
const axios_1 = __importDefault(require("axios"));
const cheerio = __importStar(require("cheerio"));
const ALLOWED_CONTENT_TYPES = [
    "text/html",
    "application/json",
    "application/xml",
    "application/javascript",
    "text/plain",
];
const DEFAULT_HEADERS = {
    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Encoding": "gzip, deflate",
    "Accept-Language": "en-US,en;q=0.5",
    "Alt-Used": "LEAVE-THIS-KEY-SET-BY-TOOL",
    Connection: "keep-alive",
    Host: "LEAVE-THIS-KEY-SET-BY-TOOL",
    Referer: "https://www.google.com/",
    "Sec-Fetch-Dest": "document",
    "Sec-Fetch-Mode": "navigate",
    "Sec-Fetch-Site": "cross-site",
    "Upgrade-Insecure-Requests": "1",
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0",
};
class WebFetcher {
    constructor(config) {
        this._config = Object.assign({
            htmlToText: true,
            summarizeHtml: false,
        }, config);
    }
    fetch(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data, contentType } = yield this.fetchPage(uri);
            if (contentType === "text/html" && this._config.htmlToText) {
                return this.extractText(data, uri, this._config.summarizeHtml);
            }
            else {
                return data;
            }
        });
    }
    extractText(html, baseUrl, summarize) {
        // Parse all elements including <noscript> tags
        const $ = cheerio.load(html, { scriptingEnabled: true });
        // If we want a summary, just get use the <body/>
        let text = '';
        $(`${summarize ? 'body ' : '*'}:not(style):not(script):not(svg)`).each((i, elem) => {
            var _a, _b;
            // Remove any children to avoid duplicate text
            let content = $(elem).clone().children().remove().end().text().trim();
            const $el = $(elem);
            // Print links in markdown format
            let href = $el.attr("href");
            if (((_a = $el.prop("tagName")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "a" && href) {
                if (!href.startsWith("http")) {
                    // Try converting to a relevant link
                    try {
                        href = new URL(href, baseUrl).toString();
                    }
                    catch (_c) {
                        // Leave as is
                    }
                }
                // If the link has content, use that as the text
                const altText = (_b = $el.find("img[alt]").attr("alt")) === null || _b === void 0 ? void 0 : _b.trim();
                if (altText) {
                    content += ` ${altText}`;
                }
                text += ` [${content}](${href})`;
            }
            // otherwise just print the content
            else if (content !== "") {
                text += ` ${content}`;
            }
        });
        // Remove newlines
        return text.trim().replace(/\n+/g, ' ');
    }
    fetchPage(baseUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpClient = axios_1.default.create({
                validateStatus: () => true,
            });
            // Clone headers to avoid mutating the original
            const headers = Object.assign({}, DEFAULT_HEADERS, this._config.headers);
            // get hostname from url
            const host = new URL(baseUrl).hostname;
            headers['Host'] = host;
            headers['Alt-Used'] = host;
            // Fetch page and check for errors
            const response = yield httpClient.get(baseUrl, Object.assign({ headers }, this._config.requestConfig));
            if (response.status >= 400) {
                throw new Error(`Site returned an HTTP status of ${response.status}`);
            }
            // Check for valid content type
            const contentType = response.headers['content-type'];
            const contentTypeArray = contentType.split(';');
            if (!contentTypeArray[0] || !ALLOWED_CONTENT_TYPES.includes(contentTypeArray[0])) {
                throw new Error(`Site returned an invalid content type of ${contentType}`);
            }
            return { data: response.data, contentType: contentTypeArray[0] };
        });
    }
}
exports.WebFetcher = WebFetcher;
//# sourceMappingURL=WebFetcher.js.map